<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Boomsi&#39;s blog</title>
    <link>https://boomsi.github.io/</link>
    <description>Recent content on Boomsi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2019</copyright>
    <lastBuildDate>Fri, 06 Aug 2021 15:08:50 +0800</lastBuildDate><atom:link href="https://boomsi.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ES 2020</title>
      <link>https://boomsi.github.io/posts/es2020/</link>
      <pubDate>Fri, 06 Aug 2021 15:08:50 +0800</pubDate>
      
      <guid>https://boomsi.github.io/posts/es2020/</guid>
      <description>Denamic import()
Node 13.2.0+ @babel/plugin-syntax-dynamic-import
在这之前使用 ES6 module 导入模块，都是在文件顶部 import xxx from &#39;xxx&#39;，这样带来的好处有很多，譬如
 做静态语法分析 tree-shaking  但是在某些场景，一些特性又是很有用的，这些在静态导入场景没有办法实现
 有选择性的 import 从脚本中作为模块导入 延迟加载  现在它支持动态调用了&amp;hellip;譬如
if (val) { import(&amp;#34;lodash&amp;#34;).then(({ default: _ }) =&amp;gt; { console.log(_.get(val, &amp;#34;a&amp;#34;)); }); } &amp;lt;!-- async 方式 --&amp;gt; async () =&amp;gt; { if (val) { const { default: _ } = await import(&amp;#34;lodash&amp;#34;); console.log(_.get(val, &amp;#34;a&amp;#34;)); } }  虽然 import() 看起来像函数调用，但是在语法意义上更像是 super()，因此 import 并不继承自 Function.</description>
    </item>
    
    <item>
      <title>ES 2021</title>
      <link>https://boomsi.github.io/posts/es2021/</link>
      <pubDate>Fri, 06 Aug 2021 15:08:50 +0800</pubDate>
      
      <guid>https://boomsi.github.io/posts/es2021/</guid>
      <description>Features   数字分隔符(Numeric Separators)
 Node v12.5.0+ @babel/plugin-proposal-numeric-separator  为提高数字的可读性而加入的新特性 经测试在十六进制、二进制也可使用
&amp;lt;!-- 十进制 --&amp;gt; let decimal = 100_000_000_000 // 100000000000  &amp;lt;!-- 二进制 --&amp;gt; let binary = 0b1_1 // 3  &amp;lt;!-- 十六进制 --&amp;gt; let hex = 0xa_1 // 161   Promise.any()
Node 15.0.0+
Promise 静态方法目前四种 Promise.all() Promise.race() Promise.allSettled() Promise.any()
简单来说
 Promise.all() 所有 Promise 状态都 fulfilled ，才 resolve，否则 reject Promise.allSettled() 所有 Promise 状态均变更 (fulfilled|rejected) 才结束 Promise.race() 存在 Promise 状态变更 fulfilled|rejected，就 resolve|reject Promise.</description>
    </item>
    
  </channel>
</rss>
